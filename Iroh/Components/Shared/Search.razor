@inject ISearchThingService SearchThingService
@inject ITagService TagService
@inject IUpvoteService UpvoteService
@inject NavigationManager NavigationManager
@using System.Linq
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@inject AuthenticationStateProvider AuthenticationStateProvider

@rendermode @(new InteractiveServerRenderMode(prerender: false))

<!-- Tag functionalities -->
@if (tags != null && chosen != null)
{
    var groupedTags = tags.GroupBy(tag => tag.Family)
                          .OrderBy(group => group.Key); // Sortiere nach Enum-Wert der Familie

    @foreach (var group in groupedTags)
    {
        <div role="group" aria-label="checkboxgroup">
            <label class="fw-bold fs-5 mt-0 ms-1">@group.Key</label>

            @for (int i = 0; i < group.Count(); i++)
            {
                var tag = group.ElementAt(i);
                var index = tags.IndexOf(tag);  // Um den richtigen Index von "chosen" zu behalten

                string btnid = "btncheck" + tag.Name;
                <input type="checkbox" class="btn-check" id="@btnid" autocomplete="off" @bind="chosen[index]">
                <label class="btn btn-outline-primary ms-1 mt-1" for="@btnid">@tag.Name</label>
            }
        </div>
    }
}
<br />
<!-- Sorting -->
<InputRadioGroup @bind-Value="sortBy">
    <div class="form-check form-check-inline ms-2">
        <InputRadio Value="@sortOptions[0]" class="form-check-input" id="SortByUpvotes"/> 
        <label class="form-check-label" for="SortByUpvotes">@sortOptions[0]</label>
    </div>

    <div class="form-check form-check-inline">
        <InputRadio Value="@sortOptions[1]" class="form-check-input" id="SortByNew" />
        <label class="form-check-label" for="SortByNew">@sortOptions[1]</label>
    </div>
</InputRadioGroup>
<button class="btn btn-primary" @onclick="@(() => SearchButtonPressed())">Search</button>
@if (isPopupVisible)
{
    <label class="ms-3">Found nothing!</label>
}
<!-- Displaying Things-->
@if (things == null)
{
    <p><em>Loading...</em></p>
}else
{
    <table class="table table-striped table-bordered m-2">
        <thead>
            <tr>
                <th scope="col">Name</th>
                <th scope="col">Description</th>
                <th scope="col">Upvotes</th>
                <AuthorizeView>
                    <Authorized>
                        <th scope="col">Upvote</th>
                    </Authorized>
                </AuthorizeView>
                
            </tr>
        </thead>
        <tbody class="table-group-divider">
            @foreach (var thing in things)
            {
                <tr>
                    <td scope="col">@thing.Name</td>
                    <td scope="col">@thing.Description</td>
                    <td scope="col">@thing.Upvotes</td>
                    <AuthorizeView>
                        <Authorized>
                            <td><button class="btn btn-info" @onclick="@(() => UpvoteThing(thing.Id, userId))">Vote</button></td>
                        </Authorized>
                    </AuthorizeView>
                </tr>
            }
        </tbody>
    </table>
}
<nav class="m-2" aria-label="Page navigation example">
    <ul class="pagination">
        <li class="page-item">
            <button class="page-link" @onclick="@(() => ChangePage(-1))">
                <span aria-hidden="true">&laquo;</span>
            </button>
        </li>
        <li class="page-item"><label class="page-link">@currentPage</label></li>
        <li class="page-item">
            <button class="page-link" @onclick="@(() => ChangePage(1))">
                <span aria-hidden="true">&raquo;</span>
            </button>
        </li>
    </ul>
</nav>
<Iroh.Components.Shared.Book Things=@things />
<!-- Code -->

@code {
    [Parameter]
    public UsedInApp App { get; set; }
    // for the tag functionalities but also needed for displaying things
    private List<Tag>? tags;
    private bool[]? chosen;
    private string[] sortOptions = ["Upvotes", "New"];
    private string? sortBy;
    private int currentPage;
    private bool isPopupVisible;
    // for displaying things
    private List<Thing>? things;
    // for upvote functionalities
    private string userId;


    protected override async Task OnInitializedAsync()
    {
        // for tag functionalities but also needed for displaying things
        TagFamily[] families = TagService.GetTagFamilies(App);
        tags = await SearchThingService.GetTagsByFamilies(families);
        chosen = new bool[tags.Count];
        sortBy = sortOptions[0];
        currentPage = 1;
        isPopupVisible = false;
        // for upvote functionalities
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        userId = "unknown";
        if (user.Identity != null & user.Identity.IsAuthenticated)
        {
            userId = user.FindFirst(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        }
        await StartSearch();
    }
    private async Task SearchButtonPressed()
    {
        this.currentPage = 1;
        await StartSearch();
    }
    <!-- MACH EINE VOR-METHODE FÜR STARTSEARCH WENN DER SEARCHBUTTON GEDRÜCKT WIRD UM CURRENTPAGE AUF 1 ZU SETTEN. -->
    private async Task<bool> StartSearch()
    {   // Service supports when no tag is selected. will just return all things inside the app.
        List<int> chosenTagIds = new List<int>();
        if (!chosen.All(tag => !tag))
        {
            Tag[] chosenTags = tags.Where((tag, index) => chosen[index]).ToArray();
            chosenTagIds = chosenTags.Select(tag => tag.Id).ToList();
        }
        //TODO: Current page
        List<Thing> foundthings = await SearchThingService.GetThingsByTags(chosenTagIds, sortBy: sortBy, app: App, currentPage: currentPage);
        if (foundthings.Count > 0)
        {
            things = foundthings;
            return true;
        }
        ShowPopup();
        return false;
    }
    private async Task UpvoteThing(int thingid, string userid)
    {
        var thing = things.FirstOrDefault(t => t.Id == thingid);
        if (thing == null) return;

        // nutze helper der ein bool zurückgibt wenn true, thing.Upvotes++ und erstelle ein Upvote Objekt (in einem Helper)
        bool doesExist = await UpvoteService.DoesUpvoteExistAlready(thingid, userid);
        bool successfullProcess = false;
        if (doesExist)
        {
            successfullProcess = await UpvoteService.RemoveUpvote(thingid, userid);
        }
        else
        {
            successfullProcess = await UpvoteService.CreateUpvote(thingid, userid);
        }
    }
    private async Task ChangePage(int changerate)
    {
        this.currentPage += changerate;
        if(this.currentPage < 1)
        {
            this.currentPage = 1;
        }
        bool isNextPageEmpty = !(await StartSearch());
        if(isNextPageEmpty)
        {
            this.currentPage -= changerate;
        }
    }
    private async void ShowPopup()
    {
        isPopupVisible = true;
        StateHasChanged(); // UI sofort aktualisieren
        await Task.Delay(2000); // 3 Sekunden warten
        isPopupVisible = false;
        StateHasChanged(); // Popup ausblenden
    }
}
