@inject ISearchThingService SearchThingService
@inject ITagService TagService
@inject IUpvoteService UpvoteService
@inject NavigationManager NavigationManager
@using System.Linq
@using Microsoft.AspNetCore.Components.Authorization
@using System.Security.Claims
@inject AuthenticationStateProvider AuthenticationStateProvider

@rendermode @(new InteractiveServerRenderMode(prerender: false))

<!-- Tag functionalities -->
<br />

@if (tags != null && chosen != null)
{
    var groupedTags = tags.GroupBy(tag => tag.Family)
                          .OrderBy(group => group.Key); // Sortiere nach Enum-Wert der Familie

    @foreach (var group in groupedTags)
    {
        <p>@group.Key</p>
        @for (int i = 0; i < group.Count(); i++)
        {
            var tag = group.ElementAt(i);
            var index = tags.IndexOf(tag);  // Um den richtigen Index von "chosen" zu behalten

            <label class="btn">
                <input type="checkbox" @bind="chosen[index]" /> @tag.Name
            </label>
        }
    }
}
<br />
<InputRadioGroup @bind-Value="sortBy">
    <label class="btn">
        <InputRadio Value="@sortOptions[0]"/> @sortOptions[0]
    </label>
    <label class="btn">
        <InputRadio Value="@sortOptions[1]"/> @sortOptions[1]
    </label>
</InputRadioGroup>
<button @onclick="@(() => StartSearch())">Search</button>

<!-- Displaying Things-->
@if (things == null)
{
    <p><em>Loading...</em></p>
}else
{
    <table class="table">
        <thead>
            <tr>
                <th>Name</th>
                <th>Description</th>
                <th>Upvotes</th>
                <AuthorizeView>
                    <Authorized>
                        <th>Upvote</th>
                    </Authorized>
                </AuthorizeView>
                
            </tr>
        </thead>
        <tbody>
            @foreach (var thing in things)
            {
                <tr>
                    <td>@thing.Name</td>
                    <td>@thing.Description</td>
                    <td>@thing.Upvotes</td>
                    <AuthorizeView>
                        <Authorized>
                            <td><button class="btn btn-primary" @onclick="@(() => UpvoteThing(thing.Id, userId))">Vote</button></td>
                        </Authorized>
                    </AuthorizeView>
                </tr>
            }
        </tbody>
    </table>
}
<button @onclick="@(() => ChangePage(-1))"> Previous Page </button>
<label>@currentPage</label>
<button @onclick="@(() => ChangePage(1))"> Next Page </button>
@if (isPopupVisible)
{
    <div class="popup">
        <p>Found nothing!</p>
    </div>
}
<!-- Code -->

@code {
    [Parameter]
    public UsedInApp App { get; set; }
    // for the tag functionalities but also needed for displaying things
    private List<Tag>? tags;
    private bool[]? chosen;
    private string[] sortOptions = ["Upvotes", "New"];
    private string? sortBy;
    private int currentPage;
    private bool isPopupVisible;
    // for displaying things
    private List<Thing>? things;
    // for upvote functionalities
    private string userId;


    protected override async Task OnInitializedAsync()
    {
        // for tag functionalities but also needed for displaying things
        TagFamily[] families = TagService.GetTagFamilies(App);
        tags = await SearchThingService.GetTagsByFamilies(families);
        chosen = new bool[tags.Count];
        sortBy = sortOptions[0];
        currentPage = 1;
        isPopupVisible = false;
        // for upvote functionalities
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        userId = "unknown";
        if (user.Identity != null & user.Identity.IsAuthenticated)
        {
            userId = user.FindFirst(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
        }
        await StartSearch();
    }
    private async Task<bool> StartSearch()
    {   // Service supports when no tag is selected. will just return all things inside the app.
        List<int> chosenTagIds = new List<int>();
        if (!chosen.All(tag => !tag))
        {
            Tag[] chosenTags = tags.Where((tag, index) => chosen[index]).ToArray();
            chosenTagIds = chosenTags.Select(tag => tag.Id).ToList();
        }
        //TODO: Current page
        List<Thing> foundthings = await SearchThingService.GetThingsByTags(chosenTagIds, sortBy: sortBy, app: App, currentPage: currentPage);
        if (foundthings.Count > 0)
        {
            things = foundthings;
            return true;
        }
        return false;
    }
    private async Task UpvoteThing(int thingid, string userid)
    {
        var thing = things.FirstOrDefault(t => t.Id == thingid);
        if (thing == null) return;

        // nutze helper der ein bool zurückgibt wenn true, thing.Upvotes++ und erstelle ein Upvote Objekt (in einem Helper)
        bool doesExist = await UpvoteService.DoesUpvoteExistAlready(thingid, userid);
        bool successfullProcess = false;
        if (doesExist)
        {
            successfullProcess = await UpvoteService.RemoveUpvote(thingid, userid);
        }
        else
        {
            successfullProcess = await UpvoteService.CreateUpvote(thingid, userid);
        }
    }
    private async Task ChangePage(int changerate)
    {
        this.currentPage += changerate;
        if(this.currentPage < 1)
        {
            this.currentPage = 1;
        }
        bool isNextPageEmpty = !(await StartSearch());
        if(isNextPageEmpty)
        {
            this.currentPage -= changerate;
            await ShowPopup();
        }
    }
    private async Task ShowPopup()
    {
        isPopupVisible = true;
        StateHasChanged(); // UI sofort aktualisieren
        await Task.Delay(3000); // 3 Sekunden warten
        isPopupVisible = false;
        StateHasChanged(); // Popup ausblenden
    }
}
